// src/components/BookProfile.js

import React, { useState, useEffect } from "react";
import { useLocation } from "react-router-dom";
import axios from "axios";
import StarRating from "./StarRating";
import { ToastContainer, toast } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
import {
  Box,
  Button,
  Card,
  CardContent,
  Container,
  Grid,
  TextField,
  Typography,
} from "@mui/material";

const palette = {
  green: "#4caf50",
  blue: "#2196f3",
  orange: "#ff9800",
  lightGray: "#f0f0f0",
  gray: "#ccc",
  pinkLight: "#F6A5C0",
  pink: "#F48FB1",
  blueLight: "#C2EAFC",
  pinkDark: "#FFC5D2",
  redLight: "#EF9A9A",
  purple: "#CE93D8",
  offWhite: "#FFF9E7",
};

export default function BookProfile() {
  const location = useLocation();
  const { book } = location.state || {};

  const [status, setStatus] = useState(null);
  const [loading, setLoading] = useState(true);
  const [user, setUser] = useState(null);
  const [reviews, setReviews] = useState([]);
  const [userReview, setUserReview] = useState(null);
  const [rating, setRating] = useState(0);
  const [reviewText, setReviewText] = useState("");
  const [isEditing, setIsEditing] = useState(false);
  const [comments, setComments] = useState([]);
  const [newComment, setNewComment] = useState("");
  const [replyCommentId, setReplyCommentId] = useState(null);
  const [newReply, setNewReply] = useState("");

  useEffect(() => {
    fetchComments();
  }, [reviewId]);

  const fetchComments = async () => {
    try {
      const res = await axios.get(
        `http://localhost:4000/comments/review/${reviewId}`,
        {
          headers: {
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
        }
      );
      setComments(res.data);
    } catch (error) {
      toast.error("Failed to load comments.");
    }
  };

  const handleAddComment = async () => {
    if (!newComment.trim()) {
      toast.warn("Please enter a comment.");
      return;
    }

    try {
      const res = await axios.post(
        "http://localhost:4000/comments/add",
        {
          reviewId,
          content: newComment,
        },
        {
          headers: {
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
        }
      );
      setComments([res.data.comment, ...comments]);
      setNewComment("");
      toast.success("Comment added successfully.");
    } catch (error) {
      toast.error("Failed to add comment.");
    }
  };

  const handleAddReply = async (parentCommentId) => {
    if (!newReply.trim()) {
      toast.warn("Please enter a reply.");
      return;
    }

    try {
      const res = await axios.post(
        "http://localhost:4000/comments/reply",
        {
          reviewId,
          parentCommentId,
          content: newReply,
        },
        {
          headers: {
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
        }
      );
      setComments(
        comments.map((comment) =>
          comment._id === parentCommentId
            ? { ...comment, replies: [res.data.reply, ...comment.replies] }
            : comment
        )
      );
      setNewReply("");
      setReplyCommentId(null);
      toast.success("Reply added successfully.");
    } catch (error) {
      toast.error("Failed to add reply.");
    }
  };
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const token = localStorage.getItem("token");
        if (!token) {
          toast.error("You need to be logged in to view this page.");
          setLoading(false);
          return;
        }
        const config = {
          headers: { Authorization: `Bearer ${token}` },
        };

        const [profileRes, booksRes] = await Promise.all([
          axios.get("http://localhost:4000/users/profile", config),
          axios.get("http://localhost:4000/users/books", config),
        ]);

        const userData = profileRes.data;
        setUser(userData);

        const { wantToRead, reading, read } = booksRes.data;

        if (
          wantToRead.some(
            (item) =>
              item.bookId && item.bookId._id?.toString() === book._id.toString()
          )
        ) {
          setStatus("Want to Read");
        } else if (
          reading.some(
            (item) =>
              item.bookId && item.bookId._id?.toString() === book._id.toString()
          )
        ) {
          setStatus("Reading");
        } else if (
          read.some(
            (item) =>
              item.bookId && item.bookId._id?.toString() === book._id.toString()
          )
        ) {
          setStatus("Read");
        } else {
          setStatus(null);
        }

        const reviewsResponse = await axios.get(
          `http://localhost:4000/reviews/book/${book._id}`
        );
        setReviews(reviewsResponse.data);

        try {
          const userReviewResponse = await axios.get(
            `http://localhost:4000/reviews/user-review`,
            {
              headers: { Authorization: `Bearer ${token}` },
              params: { bookId: book._id },
            }
          );
          setUserReview(userReviewResponse.data);
          setRating(userReviewResponse.data.rating);
          setReviewText(userReviewResponse.data.review);
        } catch (reviewError) {
          if (reviewError.response && reviewError.response.status === 404) {
            setUserReview(null);
          } else {
            console.error("Error fetching user review:", reviewError);
            toast.error("Failed to fetch your review. Please try again later.");
          }
        }
      } catch (error) {
        console.error("Error fetching data:", error);
        toast.error("Failed to fetch data. Please try again later.");
      } finally {
        setLoading(false);
      }
    };

    if (book) {
      fetchData();
    }
  }, [book]);

  const handleStatusChange = async (newStatus) => {
    try {
      const token = localStorage.getItem("token");
      if (!token) {
        toast.error("You need to be logged in to perform this action.");
        return;
      }
      const config = {
        headers: { Authorization: `Bearer ${token}` },
      };
      const endpoint = `http://localhost:4000/users/update-status/${newStatus
        .toLowerCase()
        .replace(/\s+/g, "-")}`;

      const response = await axios.post(
        endpoint,
        {
          bookId: book._id,
          bookName: book.name,
        },
        config
      );

      if (response.data && response.data.message) {
        toast.success(response.data.message);
      } else {
        toast.success(`Status updated to "${newStatus}"`);
      }

      if (newStatus === "Read" && !userReview) {
        setIsEditing(true);
        toast.info("Please rate and review the book.");
      }

      const [profileRes, booksRes] = await Promise.all([
        axios.get("http://localhost:4000/users/profile", config),
        axios.get("http://localhost:4000/users/books", config),
      ]);

      const userData = profileRes.data;
      setUser(userData);

      const { wantToRead, reading, read } = booksRes.data;

      if (
        wantToRead.some(
          (item) =>
            item.bookId && item.bookId._id?.toString() === book._id.toString()
        )
      ) {
        setStatus("Want to Read");
      } else if (
        reading.some(
          (item) =>
            item.bookId && item.bookId._id?.toString() === book._id.toString()
        )
      ) {
        setStatus("Reading");
      } else if (
        read.some(
          (item) =>
            item.bookId && item.bookId._id?.toString() === book._id.toString()
        )
      ) {
        setStatus("Read");
      } else {
        setStatus(null);
      }
    } catch (error) {
      console.error("Error updating reading status:", error);
      toast.error("Failed to update status. Please try again.");
    }
  };

  const handleSubmitReview = async () => {
    if (rating < 1 || rating > 5) {
      toast.warn("Please provide a rating between 1 and 5 stars.");
      return;
    }
    if (!reviewText.trim()) {
      toast.warn("Please enter a review.");
      return;
    }

    try {
      const token = localStorage.getItem("token");
      if (!token) {
        toast.error("You need to be logged in to submit a review.");
        return;
      }
      const config = {
        headers: { Authorization: `Bearer ${token}` },
      };

      if (!book._id || !book.name) {
        console.error("Book ID or name is missing.");
        toast.error("Book data is incomplete. Please try again.");
        return;
      }

      const response = await axios.post(
        "http://localhost:4000/reviews/submit",
        {
          bookId: book._id,
          rating,
          review: reviewText,
        },
        config
      );

      if (response.data && response.data.message) {
        toast.success(
          isEditing
            ? "Review updated successfully."
            : "Review submitted successfully."
        );
      } else {
        toast.error("Failed to submit review. Please try again.");
        return;
      }

      const reviewsResponse = await axios.get(
        `http://localhost:4000/reviews/book/${book._id}`
      );
      setReviews(reviewsResponse.data);

      const profileRes = await axios.get(
        "http://localhost:4000/users/profile",
        config
      );
      const userData = profileRes.data;
      setUser(userData);
    } catch (error) {
      console.error("Error submitting review:", error);
      toast.error("Failed to submit review. Please try again.");
    }
  };

  const handleEdit = () => {
    if (userReview) {
      setIsEditing(true);
    }
  };

  const handleCancelEdit = () => {
    if (userReview) {
      setRating(userReview.rating);
      setReviewText(userReview.review);
    } else {
      setRating(0);
      setReviewText("");
    }
    setIsEditing(false);
  };

  if (!book) {
    return <Typography>Book not found</Typography>;
  }

  if (loading) {
    return <Typography>Loading...</Typography>;
  }

  return (
    <Container
      maxWidth="md"
      sx={{ backgroundColor: palette.offWhite, p: 3, borderRadius: 2 }}
    >
      <Typography variant="h3" sx={{ color: palette.redLight, mb: 2 }}>
        {book.name}
      </Typography>
      <Typography variant="h6">Author: {book.author}</Typography>
      <Typography variant="body1" sx={{ mb: 2 }}>
        Genres: {book.genre.join(", ")}
      </Typography>
      <Typography variant="body1" sx={{ mb: 4 }}>
        Average Rating: {book.averageRating} ({book.numberOfRatings} ratings)
      </Typography>

      <Box sx={{ mt: 3, mb: 2 }}>
        <Button
          variant="contained"
          sx={{
            mr: 2,
            backgroundColor:
              status === "Want to Read" ? palette.green : palette.lightGray,
            color: status === "Want to Read" ? "white" : "black",
          }}
          onClick={() => handleStatusChange("Want to Read")}
        >
          Want to Read
        </Button>
        <Button
          variant="contained"
          sx={{
            mr: 2,
            backgroundColor:
              status === "Reading" ? palette.blue : palette.lightGray,
            color: status === "Reading" ? "white" : "black",
          }}
          onClick={() => handleStatusChange("Reading")}
        >
          Reading
        </Button>
        <Button
          variant="contained"
          sx={{
            backgroundColor:
              status === "Read" ? palette.orange : palette.lightGray,
            color: status === "Read" ? "white" : "black",
          }}
          onClick={() => handleStatusChange("Read")}
        >
          Read
        </Button>
      </Box>

      {status && (
        <Typography variant="body1" fontWeight="bold" sx={{ mb: 2 }}>
          Current status: {status}
        </Typography>
      )}

      {user && (
        <Typography variant="body1" fontWeight="bold" sx={{ mb: 4 }}>
          Total Books Read: {user.readCount}
        </Typography>
      )}

      <Typography variant="h4" sx={{ color: palette.pink }}>
        Reviews
      </Typography>
      <Typography variant="body1" sx={{ mb: 4 }}>
        Average Rating: {book.averageRating} ({book.numberOfRatings} ratings)
      </Typography>

      {user && (
        <Card sx={{ mb: 4, p: 3 }}>
          <Typography variant="h5">Your Review</Typography>
          {!userReview && !isEditing ? (
            <Box>
              <StarRating
                rating={rating}
                setRating={setRating}
                editable={true}
              />
              <TextField
                value={reviewText}
                onChange={(e) => setReviewText(e.target.value)}
                label="Write your review here..."
                multiline
                rows={4}
                fullWidth
                sx={{ mt: 2, mb: 2 }}
              />
              <Button
                variant="contained"
                sx={{ backgroundColor: palette.green, color: "white" }}
                onClick={handleSubmitReview}
              >
                Submit Review
              </Button>
            </Box>
          ) : isEditing ? (
            <Box>
              <StarRating
                rating={rating}
                setRating={setRating}
                editable={true}
              />
              <TextField
                value={reviewText}
                onChange={(e) => setReviewText(e.target.value)}
                label="Edit your review..."
                multiline
                rows={4}
                fullWidth
                sx={{ mt: 2, mb: 2 }}
              />
              <Button
                variant="contained"
                sx={{ mr: 2, backgroundColor: palette.green, color: "white" }}
                onClick={handleSubmitReview}
              >
                Save Changes
              </Button>
              <Button
                variant="contained"
                sx={{ backgroundColor: palette.redLight, color: "white" }}
                onClick={handleCancelEdit}
              >
                Cancel
              </Button>
            </Box>
          ) : (
            <Box>
              <StarRating
                rating={rating}
                setRating={setRating}
                editable={false}
              />
              <Typography variant="body1" sx={{ mt: 2, mb: 2 }}>
                {reviewText}
              </Typography>
              <Button
                variant="contained"
                sx={{ backgroundColor: palette.blue, color: "white" }}
                onClick={handleEdit}
              >
                Edit Review
              </Button>
            </Box>
          )}
        </Card>
      )}

      <Box>
        {reviews.map((review) => (
          <Card key={review._id} sx={{ mb: 2, p: 3 }}>
            <Typography variant="subtitle1" fontWeight="bold">
              {review.userEmail}
            </Typography>
            <StarRating rating={review.rating} editable={false} />
            <Typography variant="body2" sx={{ mt: 1, mb: 1 }}>
              {review.review}
            </Typography>
            <Typography variant="caption" sx={{ color: "gray" }}>
              {new Date(review.createdAt).toLocaleString()}
            </Typography>
          </Card>
        ))}
      </Box>

      <ToastContainer position="top-right" autoClose={3000} hideProgressBar />
    </Container>
  );
}
